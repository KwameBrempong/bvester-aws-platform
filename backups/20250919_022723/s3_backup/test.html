<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bvester Connection Diagnostic</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; }
        .test {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #ccc;
        }
        .test.success { border-color: #4caf50; background: #f1f8f4; }
        .test.error { border-color: #f44336; background: #fef1f0; }
        .test.pending { border-color: #ff9800; background: #fff8f1; }
        button {
            padding: 10px 20px;
            background: #FFD700;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover { background: #FFA500; }
        .log {
            background: #2d2d2d;
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .status { font-weight: bold; }
    </style>
</head>
<body>
    <h1>üîç Bvester Connection Diagnostic Tool</h1>
    <p>This tool will diagnose connection issues with the Bvester backend.</p>

    <div id="tests"></div>

    <button onclick="runAllTests()">Run All Tests</button>
    <button onclick="clearLogs()">Clear Logs</button>

    <h3>Detailed Log:</h3>
    <div id="log" class="log"></div>

    <script>
        const API_URL = 'https://lh4wi733jhjrlpz76bbwezpuea0drqzq.lambda-url.eu-west-2.on.aws';
        const testsDiv = document.getElementById('tests');
        const logDiv = document.getElementById('log');

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
            logDiv.textContent += logEntry;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function updateTest(id, status, message) {
            let testDiv = document.getElementById(id);
            if (!testDiv) {
                testDiv = document.createElement('div');
                testDiv.id = id;
                testDiv.className = 'test';
                testsDiv.appendChild(testDiv);
            }

            testDiv.className = `test ${status}`;
            testDiv.innerHTML = `
                <div class="status">${status.toUpperCase()}: ${id.replace(/-/g, ' ').toUpperCase()}</div>
                <div>${message}</div>
            `;
        }

        async function testBasicFetch() {
            const testId = 'basic-fetch';
            updateTest(testId, 'pending', 'Testing basic fetch capability...');

            try {
                log('Starting basic fetch test...');
                const response = await fetch('https://httpbin.org/get');
                const data = await response.json();

                if (response.ok) {
                    updateTest(testId, 'success', 'Browser fetch API is working');
                    log('Basic fetch successful', 'success');
                    return true;
                } else {
                    updateTest(testId, 'error', 'Fetch failed with status: ' + response.status);
                    log('Basic fetch failed: ' + response.status, 'error');
                    return false;
                }
            } catch (error) {
                updateTest(testId, 'error', 'Fetch error: ' + error.message);
                log('Basic fetch error: ' + error.message, 'error');
                return false;
            }
        }

        async function testDNS() {
            const testId = 'dns-resolution';
            updateTest(testId, 'pending', 'Testing DNS resolution...');

            try {
                log('Testing DNS for Lambda URL...');
                // Try to resolve the domain using a simple image request
                const img = new Image();
                const promise = new Promise((resolve, reject) => {
                    img.onload = () => resolve(true);
                    img.onerror = () => reject(false);
                    setTimeout(() => reject(false), 5000);
                });

                img.src = `${API_URL}/favicon.ico?t=${Date.now()}`;

                await promise.catch(() => false);

                updateTest(testId, 'success', 'DNS resolution working');
                log('DNS resolution successful', 'success');
                return true;
            } catch (error) {
                updateTest(testId, 'error', 'DNS resolution failed');
                log('DNS error: ' + error.message, 'error');
                return false;
            }
        }

        async function testCORS() {
            const testId = 'cors-preflight';
            updateTest(testId, 'pending', 'Testing CORS preflight...');

            try {
                log('Sending OPTIONS request for CORS check...');
                const response = await fetch(`${API_URL}/api/auth/signup`, {
                    method: 'OPTIONS',
                    headers: {
                        'Origin': window.location.origin,
                        'Access-Control-Request-Method': 'POST',
                        'Access-Control-Request-Headers': 'content-type'
                    }
                });

                const corsHeaders = {
                    'access-control-allow-origin': response.headers.get('access-control-allow-origin'),
                    'access-control-allow-methods': response.headers.get('access-control-allow-methods'),
                    'access-control-allow-headers': response.headers.get('access-control-allow-headers')
                };

                log('CORS headers received: ' + JSON.stringify(corsHeaders), 'info');

                if (response.ok) {
                    updateTest(testId, 'success', 'CORS preflight successful. Headers: ' + JSON.stringify(corsHeaders));
                    return true;
                } else {
                    updateTest(testId, 'error', 'CORS preflight failed with status: ' + response.status);
                    log('CORS preflight failed', 'error');
                    return false;
                }
            } catch (error) {
                updateTest(testId, 'error', 'CORS error: ' + error.message);
                log('CORS error: ' + error.message + ' - ' + error.stack, 'error');
                return false;
            }
        }

        async function testHealthEndpoint() {
            const testId = 'health-check';
            updateTest(testId, 'pending', 'Testing health endpoint...');

            try {
                log('Checking /health endpoint...');
                const response = await fetch(`${API_URL}/health`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const text = await response.text();
                log('Health response: ' + text, 'info');

                if (response.ok) {
                    const data = JSON.parse(text);
                    updateTest(testId, 'success', `Health check OK: ${data.message || 'API is healthy'}`);
                    return true;
                } else {
                    updateTest(testId, 'error', 'Health check failed: ' + text);
                    return false;
                }
            } catch (error) {
                updateTest(testId, 'error', 'Health check error: ' + error.message);
                log('Health check error: ' + error.message + '\nStack: ' + error.stack, 'error');
                return false;
            }
        }

        async function testSignupEndpoint() {
            const testId = 'signup-endpoint';
            updateTest(testId, 'pending', 'Testing signup endpoint...');

            const testEmail = `test${Date.now()}@diagnostic.com`;
            const payload = {
                name: 'Diagnostic Test',
                email: testEmail,
                password: 'test123',
                userType: 'sme'
            };

            try {
                log('Testing POST to /api/auth/signup with payload: ' + JSON.stringify(payload));

                const response = await fetch(`${API_URL}/api/auth/signup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Origin': window.location.origin
                    },
                    body: JSON.stringify(payload)
                });

                const text = await response.text();
                log('Signup response status: ' + response.status, 'info');
                log('Signup response body: ' + text, 'info');

                if (response.ok || response.status === 201) {
                    const data = JSON.parse(text);
                    updateTest(testId, 'success', `Signup endpoint working! Created: ${data.user?.email}`);
                    return true;
                } else if (response.status === 400) {
                    const data = JSON.parse(text);
                    if (data.error?.includes('already exists')) {
                        updateTest(testId, 'success', 'Signup endpoint working (email already exists)');
                        return true;
                    }
                    updateTest(testId, 'error', 'Signup validation error: ' + data.error);
                    return false;
                } else {
                    updateTest(testId, 'error', `Signup failed with status ${response.status}: ${text}`);
                    return false;
                }
            } catch (error) {
                updateTest(testId, 'error', 'Signup error: ' + error.message);
                log('Signup error details: ' + error.message + '\nStack: ' + error.stack, 'error');
                return false;
            }
        }

        async function testWithTimeout() {
            const testId = 'timeout-test';
            updateTest(testId, 'pending', 'Testing with timeout...');

            try {
                log('Testing with 5 second timeout...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);

                const response = await fetch(`${API_URL}/health`, {
                    method: 'GET',
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (response.ok) {
                    updateTest(testId, 'success', 'Request completed within timeout');
                    return true;
                } else {
                    updateTest(testId, 'error', 'Request failed with status: ' + response.status);
                    return false;
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateTest(testId, 'error', 'Request timed out after 5 seconds');
                    log('Request timed out', 'error');
                } else {
                    updateTest(testId, 'error', 'Timeout test error: ' + error.message);
                    log('Timeout test error: ' + error.message, 'error');
                }
                return false;
            }
        }

        async function testNetworkType() {
            const testId = 'network-info';
            updateTest(testId, 'pending', 'Checking network information...');

            try {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;

                if (connection) {
                    const info = {
                        effectiveType: connection.effectiveType,
                        downlink: connection.downlink,
                        rtt: connection.rtt,
                        saveData: connection.saveData
                    };

                    log('Network info: ' + JSON.stringify(info), 'info');
                    updateTest(testId, 'success', `Network: ${info.effectiveType}, RTT: ${info.rtt}ms, Downlink: ${info.downlink}Mbps`);
                } else {
                    updateTest(testId, 'success', 'Network API not available, but connection seems fine');
                }

                // Also check online status
                if (!navigator.onLine) {
                    updateTest(testId, 'error', 'Browser reports offline status!');
                    return false;
                }

                return true;
            } catch (error) {
                updateTest(testId, 'error', 'Network check error: ' + error.message);
                return false;
            }
        }

        async function testBrowserCompatibility() {
            const testId = 'browser-compat';
            updateTest(testId, 'pending', 'Checking browser compatibility...');

            const features = {
                fetch: typeof fetch !== 'undefined',
                promise: typeof Promise !== 'undefined',
                abortController: typeof AbortController !== 'undefined',
                localStorage: typeof localStorage !== 'undefined',
                json: typeof JSON !== 'undefined'
            };

            log('Browser features: ' + JSON.stringify(features), 'info');

            const allSupported = Object.values(features).every(v => v === true);

            if (allSupported) {
                updateTest(testId, 'success', 'All required browser features supported');
                return true;
            } else {
                const missing = Object.entries(features)
                    .filter(([k, v]) => !v)
                    .map(([k]) => k);
                updateTest(testId, 'error', 'Missing browser features: ' + missing.join(', '));
                return false;
            }
        }

        async function runAllTests() {
            log('=== Starting diagnostic tests ===', 'info');
            testsDiv.innerHTML = '';

            const tests = [
                testBrowserCompatibility,
                testNetworkType,
                testBasicFetch,
                testDNS,
                testHealthEndpoint,
                testCORS,
                testSignupEndpoint,
                testWithTimeout
            ];

            let passed = 0;
            let failed = 0;

            for (const test of tests) {
                try {
                    const result = await test();
                    if (result) passed++;
                    else failed++;
                } catch (error) {
                    failed++;
                    log('Test error: ' + error.message, 'error');
                }

                // Small delay between tests
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            log(`=== Tests complete: ${passed} passed, ${failed} failed ===`,
                failed === 0 ? 'success' : 'error');
        }

        function clearLogs() {
            logDiv.textContent = '';
            testsDiv.innerHTML = '';
        }

        // Auto-run tests on load
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 1000);
        });
    </script>
</body>
</html>